<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.151">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="David Schoch">
<meta name="dcterms.date" content="2022-04-27">
<meta name="description" content="An Introduction to Network Centrality in R using the netrankr package">

<title>Network Centrality in R</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="index_files/libs/clipboard/clipboard.min.js"></script>
<script src="index_files/libs/quarto-html/quarto.js"></script>
<script src="index_files/libs/quarto-html/popper.min.js"></script>
<script src="index_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="index_files/libs/quarto-html/anchor.min.js"></script>
<link href="index_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="index_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="index_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="index_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="index_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#required-libraries" id="toc-required-libraries" class="nav-link active" data-scroll-target="#required-libraries">Required libraries</a></li>
  <li><a href="#part-1" id="toc-part-1" class="nav-link" data-scroll-target="#part-1">Part 1</a>
  <ul class="collapse">
  <li><a href="#introduction" id="toc-introduction" class="nav-link" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#r-packages-for-centrality" id="toc-r-packages-for-centrality" class="nav-link" data-scroll-target="#r-packages-for-centrality">R packages for centrality</a></li>
  <li><a href="#a-small-example" id="toc-a-small-example" class="nav-link" data-scroll-target="#a-small-example">A small example</a></li>
  <li><a href="#an-almost-realistic-example" id="toc-an-almost-realistic-example" class="nav-link" data-scroll-target="#an-almost-realistic-example">An almost realistic example</a></li>
  <li><a href="#summary" id="toc-summary" class="nav-link" data-scroll-target="#summary">Summary</a></li>
  </ul></li>
  <li><a href="#part-2" id="toc-part-2" class="nav-link" data-scroll-target="#part-2">Part 2</a>
  <ul class="collapse">
  <li><a href="#introduction-1" id="toc-introduction-1" class="nav-link" data-scroll-target="#introduction-1">Introduction</a></li>
  <li><a href="#neighborhood-inclusion" id="toc-neighborhood-inclusion" class="nav-link" data-scroll-target="#neighborhood-inclusion">Neighborhood-inclusion</a></li>
  <li><a href="#threshold-graphs-and-correlation-among-indices" id="toc-threshold-graphs-and-correlation-among-indices" class="nav-link" data-scroll-target="#threshold-graphs-and-correlation-among-indices">Threshold graphs and correlation among indices</a></li>
  <li><a href="#summary-1" id="toc-summary-1" class="nav-link" data-scroll-target="#summary-1">Summary</a></li>
  </ul></li>
  <li><a href="#part-3" id="toc-part-3" class="nav-link" data-scroll-target="#part-3">Part 3</a>
  <ul class="collapse">
  <li><a href="#introduction-2" id="toc-introduction-2" class="nav-link" data-scroll-target="#introduction-2">Introduction</a></li>
  <li><a href="#deconstructing-indices" id="toc-deconstructing-indices" class="nav-link" data-scroll-target="#deconstructing-indices">Deconstructing Indices</a></li>
  <li><a href="#extended-dominance-relations" id="toc-extended-dominance-relations" class="nav-link" data-scroll-target="#extended-dominance-relations">Extended Dominance Relations</a></li>
  </ul></li>
  <li><a href="#partial-centrality" id="toc-partial-centrality" class="nav-link" data-scroll-target="#partial-centrality">Partial Centrality</a>
  <ul class="collapse">
  <li><a href="#probabilistic-centrality" id="toc-probabilistic-centrality" class="nav-link" data-scroll-target="#probabilistic-centrality">Probabilistic Centrality</a></li>
  <li><a href="#summary-2" id="toc-summary-2" class="nav-link" data-scroll-target="#summary-2">Summary</a></li>
  </ul></li>
  </ul>
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="index.pdf"><i class="bi bi-file-pdf"></i>PDF</a></li></ul></div></nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Network Centrality in R</h1>
<p class="subtitle lead">using indices and alternative methods</p>
  <div class="quarto-categories">
    <div class="quarto-category">network analysis</div>
    <div class="quarto-category">R</div>
  </div>
  </div>

<div>
  <div class="description">
    <p>An Introduction to Network Centrality in R using the netrankr package</p>
  </div>
</div>

<div class="quarto-title-meta-author">
  <div class="quarto-title-meta-heading">Author</div>
  <div class="quarto-title-meta-heading">Affiliation</div>
  
    <div class="quarto-title-meta-contents">
    <p class="author"><a href="https://mr.schochastics.net">David Schoch</a> <a href="https://orcid.org/0000-0003-1689-0557" class="quarto-title-author-orcid"> <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1N0NEMjA4MDI1MjA2ODExOTk0QzkzNTEzRjZEQTg1NyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0NDOEJGNEZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0NDOEJGM0ZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkZDN0YxMTc0MDcyMDY4MTE5NUZFRDc5MUM2MUUwNEREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU3Q0QyMDgwMjUyMDY4MTE5OTRDOTM1MTNGNkRBODU3Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+84NovQAAAR1JREFUeNpiZEADy85ZJgCpeCB2QJM6AMQLo4yOL0AWZETSqACk1gOxAQN+cAGIA4EGPQBxmJA0nwdpjjQ8xqArmczw5tMHXAaALDgP1QMxAGqzAAPxQACqh4ER6uf5MBlkm0X4EGayMfMw/Pr7Bd2gRBZogMFBrv01hisv5jLsv9nLAPIOMnjy8RDDyYctyAbFM2EJbRQw+aAWw/LzVgx7b+cwCHKqMhjJFCBLOzAR6+lXX84xnHjYyqAo5IUizkRCwIENQQckGSDGY4TVgAPEaraQr2a4/24bSuoExcJCfAEJihXkWDj3ZAKy9EJGaEo8T0QSxkjSwORsCAuDQCD+QILmD1A9kECEZgxDaEZhICIzGcIyEyOl2RkgwAAhkmC+eAm0TAAAAABJRU5ErkJggg=="></a></p>
  </div>
    <div class="quarto-title-meta-contents">
        <p class="affiliation">
            GESIS - Leibniz Institute for the Social Sciences
          </p>
      </div>
    </div>

<div class="quarto-title-meta">

      
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">April 27, 2022</p>
    </div>
  </div>
  
    
  </div>
  

</header>

<section id="required-libraries" class="level2">
<h2 class="anchored" data-anchor-id="required-libraries">Required libraries</h2>
<p>To run all the code in this tutorial, you need to install and load several packages.</p>
<div class="cell" data-hash="index_cache/html/install_libraries_59ebdd0128b265418cb308b5403672df">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">install.packages</span>(<span class="fu">c</span>(<span class="st">"igraph"</span>, <span class="st">"netrankr"</span>, <span class="st">"centiserve"</span>,<span class="st">"sna"</span>,<span class="st">"expm"</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-hash="index_cache/html/loadlibs_1e3ebf183cd25bc6345ae24478b57b7c">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(netrankr)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(igraph)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="part-1" class="level1">
<h1>Part 1</h1>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>One of the many tools to analyze networks are measures of <em>centrality</em>. In a nutshell, a measure of centrality is an index that assigns a numeric values to the nodes of the network. The higher the value, the more central the node.</p>
</section>
<section id="r-packages-for-centrality" class="level2">
<h2 class="anchored" data-anchor-id="r-packages-for-centrality">R packages for centrality</h2>
<p>(<em>This section lists a great variety of different indices. If you are interested in the technical details, consult the help of the function and check out the references</em>)</p>
<p>There are several packages that implement centrality indices for R. Of course, there are the big network and graph packages such as <code>igraph</code>,<code>sna</code>, <code>qgraph</code>, and <code>tidygraph</code>, which are designed as general purpose packages for network analysis. Hence, they also implement some centrality indices.</p>
<p><code>igraph</code> contains the following 10 indices:</p>
<ul>
<li>degree (<code>degree()</code>)</li>
<li>weighted degree (<code>graph.strength()</code>)</li>
<li>betweenness (<code>betweenness()</code>)</li>
<li>closeness (<code>closeness()</code>)</li>
<li>eigenvector (<code>eigen_centrality()</code>)</li>
<li>alpha centrality (<code>alpha_centrality()</code>)</li>
<li>power centrality (<code>power_centrality()</code>)</li>
<li>PageRank (<code>page_rank()</code>)</li>
<li>eccentricity (<code>eccentricity()</code>)</li>
<li>hubs and authorities (<code>authority_score()</code> and <code>hub_score()</code>)</li>
<li>subgraph centrality (<code>subgraph_centrality()</code>)</li>
</ul>
<p>In most cases, parameters can be adjusted to account for directed/undirected and weighted/unweighted networks.</p>
<p>The <code>sna</code> package implements roughly the same indices together with:</p>
<ul>
<li>flow betweenness (<code>flowbet()</code>)</li>
<li>load centrality (<code>loadcent()</code>)</li>
<li>Gil-Schmidt Power Index (<code>gilschmidt()</code>)</li>
<li>information centrality (<code>infocent()</code>)</li>
<li>stress centrality (<code>stresscent()</code>)</li>
</ul>
<p><code>qgraph</code> specializes on weighted networks. It has a generic function <code>centrality_auto()</code> which returns, depending on the network, the following indices:</p>
<ul>
<li>degree</li>
<li>strength (weighted degree)</li>
<li>betweenness</li>
<li>closeness</li>
</ul>
<p>The package also contains the function <code>centrality()</code>, which calculates a non-linear combination of unweighted and weighted indices using a tuning parameter <span class="math inline">\(\alpha\)</span> (See <a href="https://www.sciencedirect.com/science/article/pii/S0378873310000183">Opsahl et al.</a>).</p>
<p>There are also some dedicated centrality packages, such as <code>centiserve</code>, <code>CINNA</code>, <code>influenceR</code> and <code>keyplayer</code>. The biggest in terms of implemented indices is currently <code>centiserve</code> with a total of 33 indices.</p>
<p>The package is maintained by the team behind <a href="http://www.centiserver.org/">centiserver</a>, the “comprehensive centrality resource and server for centralities calculation”. The website collects indices found in the literature. Currently (April 2023), it lists 403 different indices.</p>
<p><code>CINNA</code> is a fairly new package. The package description says “Functions for computing, comparing and demonstrating top informative centrality measures within a network.” Most of the indices in the package are imported from other package, such as <code>centiserve</code>. In addition, there are:</p>
<ul>
<li>Dangalchev closeness (<code>dangalchev_closeness_centrality()</code>)</li>
<li>group centrality (<code>group_centrality()</code>)</li>
<li>harmonic closeness (<code>harmonic_centrality()</code>)</li>
<li>local bridging centrality (<code>local_bridging_centrality()</code>)</li>
</ul>
<p>The function <code>calculate_centralities()</code> can be used to calculate all applicable indices to a network. The primary purpose of the package is to facilitate the choice of indices by visual and statistical tools. If you are interested in the details, see this <a href="https://www.datacamp.com/community/tutorials/centrality-network-analysis-R">tutorial</a> and this <a href="https://cran.r-project.org/web/packages/CINNA/vignettes/CINNA.html">vignette</a>.</p>
<p><code>influenceR</code> and <code>keyplayer</code> are comparably small packages which implement only a small number of indices.</p>
<p><em>(For now, I deliberately leave out my package <code>netrankr</code>. While it implements a great variety of indices, it is not its primary purpose to provide a set of predefined measures. We will come to that in the next part.)</em></p>
</section>
<section id="a-small-example" class="level2">
<h2 class="anchored" data-anchor-id="a-small-example">A small example</h2>
<p>Let us start with a fairly simple example. Consider the following two small networks.</p>
<div class="cell" data-hash="index_cache/html/loadexamples_aa6e515f39c446f852dc32fd3bf565fd">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">#data can be found here: https://github.com/schochastics/centrality</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>g1 <span class="ot">&lt;-</span> <span class="fu">readRDS</span>(<span class="st">"example_1.rds"</span>)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>g2 <span class="ot">&lt;-</span> <span class="fu">readRDS</span>(<span class="st">"example_2.rds"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><img src="example.png" class="img-fluid"></p>
<p>Now, without any empirical context, we want to determine the most central node in both networks. I wrote a small function which calculates 35 of the above mentioned indices.</p>
<div class="cell" data-hash="index_cache/html/helper_1914b8dcc60e74a5aa42bc6577fae08f">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="fu">require</span>(expm)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>all_indices <span class="ot">&lt;-</span> <span class="cf">function</span>(g){</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  res <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="dv">0</span>,<span class="fu">vcount</span>(g),<span class="dv">35</span>)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  res[,<span class="dv">1</span>] <span class="ot">&lt;-</span> igraph<span class="sc">::</span><span class="fu">degree</span>(g)</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  res[,<span class="dv">2</span>] <span class="ot">&lt;-</span> igraph<span class="sc">::</span><span class="fu">betweenness</span>(g)</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  res[,<span class="dv">3</span>] <span class="ot">&lt;-</span> igraph<span class="sc">::</span><span class="fu">closeness</span>(g)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>  res[,<span class="dv">4</span>] <span class="ot">&lt;-</span> igraph<span class="sc">::</span><span class="fu">eigen_centrality</span>(g)<span class="sc">$</span>vector</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>  res[,<span class="dv">5</span>] <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">/</span>igraph<span class="sc">::</span><span class="fu">eccentricity</span>(g)</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>  res[,<span class="dv">6</span>] <span class="ot">&lt;-</span> igraph<span class="sc">::</span><span class="fu">subgraph_centrality</span>(g)</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>  A <span class="ot">&lt;-</span> <span class="fu">get.adjacency</span>(g,<span class="at">sparse=</span>F)</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>  res[,<span class="dv">7</span>] <span class="ot">&lt;-</span> sna<span class="sc">::</span><span class="fu">flowbet</span>(A)</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>  res[,<span class="dv">8</span>] <span class="ot">&lt;-</span> sna<span class="sc">::</span><span class="fu">loadcent</span>(A)</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>  res[,<span class="dv">9</span>] <span class="ot">&lt;-</span> sna<span class="sc">::</span><span class="fu">gilschmidt</span>(A)</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>  res[,<span class="dv">10</span>] <span class="ot">&lt;-</span> sna<span class="sc">::</span><span class="fu">infocent</span>(A)</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>  res[,<span class="dv">11</span>] <span class="ot">&lt;-</span> sna<span class="sc">::</span><span class="fu">stresscent</span>(A)</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>  res[,<span class="dv">12</span>] <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">/</span>centiserve<span class="sc">::</span><span class="fu">averagedis</span>(g)</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>  res[,<span class="dv">13</span>] <span class="ot">&lt;-</span> centiserve<span class="sc">::</span><span class="fu">barycenter</span>(g)</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>  res[,<span class="dv">14</span>] <span class="ot">&lt;-</span> centiserve<span class="sc">::</span><span class="fu">closeness.currentflow</span>(g)</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>  res[,<span class="dv">15</span>] <span class="ot">&lt;-</span> centiserve<span class="sc">::</span><span class="fu">closeness.latora</span>(g)</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>  res[,<span class="dv">16</span>] <span class="ot">&lt;-</span> centiserve<span class="sc">::</span><span class="fu">closeness.residual</span>(g)</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>  res[,<span class="dv">17</span>] <span class="ot">&lt;-</span> centiserve<span class="sc">::</span><span class="fu">communibet</span>(g)</span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>  res[,<span class="dv">18</span>] <span class="ot">&lt;-</span> centiserve<span class="sc">::</span><span class="fu">crossclique</span>(g)</span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>  res[,<span class="dv">19</span>] <span class="ot">&lt;-</span> centiserve<span class="sc">::</span><span class="fu">decay</span>(g)</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>  res[,<span class="dv">20</span>] <span class="ot">&lt;-</span> centiserve<span class="sc">::</span><span class="fu">diffusion.degree</span>(g)     </span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>  res[,<span class="dv">21</span>] <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">/</span>centiserve<span class="sc">::</span><span class="fu">entropy</span>(g)</span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>  res[,<span class="dv">22</span>] <span class="ot">&lt;-</span> centiserve<span class="sc">::</span><span class="fu">geokpath</span>(g)</span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>  res[,<span class="dv">23</span>] <span class="ot">&lt;-</span> centiserve<span class="sc">::</span><span class="fu">katzcent</span>(g)             </span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>  res[,<span class="dv">24</span>] <span class="ot">&lt;-</span> centiserve<span class="sc">::</span><span class="fu">laplacian</span>(g)</span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>  res[,<span class="dv">25</span>] <span class="ot">&lt;-</span> centiserve<span class="sc">::</span><span class="fu">leverage</span>(g)             </span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>  res[,<span class="dv">26</span>] <span class="ot">&lt;-</span> centiserve<span class="sc">::</span><span class="fu">lincent</span>(g)</span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>  res[,<span class="dv">27</span>] <span class="ot">&lt;-</span> centiserve<span class="sc">::</span><span class="fu">lobby</span>(g)</span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>  res[,<span class="dv">28</span>] <span class="ot">&lt;-</span> centiserve<span class="sc">::</span><span class="fu">markovcent</span>(g)           </span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a>  res[,<span class="dv">29</span>] <span class="ot">&lt;-</span> centiserve<span class="sc">::</span><span class="fu">mnc</span>(g)</span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a>  res[,<span class="dv">30</span>] <span class="ot">&lt;-</span> centiserve<span class="sc">::</span><span class="fu">radiality</span>(g)            </span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a>  res[,<span class="dv">31</span>] <span class="ot">&lt;-</span> centiserve<span class="sc">::</span><span class="fu">semilocal</span>(g)</span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a>  res[,<span class="dv">32</span>] <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">/</span>centiserve<span class="sc">::</span><span class="fu">topocoefficient</span>(g) </span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a>  res[,<span class="dv">33</span>] <span class="ot">&lt;-</span> CINNA<span class="sc">::</span><span class="fu">dangalchev_closeness_centrality</span>(g)</span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a>  res[,<span class="dv">34</span>] <span class="ot">&lt;-</span> CINNA<span class="sc">::</span><span class="fu">harmonic_centrality</span>(g)</span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true" tabindex="-1"></a>  res[,<span class="dv">35</span>] <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">/</span>CINNA<span class="sc">::</span><span class="fu">local_bridging_centrality</span>(g)</span>
<span id="cb4-43"><a href="#cb4-43" aria-hidden="true" tabindex="-1"></a>  <span class="fu">apply</span>(res,<span class="dv">2</span>,<span class="cf">function</span>(x) <span class="fu">round</span>(x,<span class="dv">8</span>))</span>
<span id="cb4-44"><a href="#cb4-44" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We blindly apply them to both networks and see what happens.</p>
<div class="cell" data-hash="index_cache/html/examplecalc_d03310010aad4ccf8cd0780055cb3e3e">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>res1 <span class="ot">&lt;-</span> <span class="fu">all_indices</span>(g1)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>res2 <span class="ot">&lt;-</span> <span class="fu">all_indices</span>(g2)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The chart below shows a breakdown for how many indices return a specific node as the most central one.</p>
<p><img src="most_central.png" class="img-fluid"></p>
<p>In network 1, five different nodes are considered to be “the most central node” by different indices. In network 2, on the other hand, all 35 indices agree on node eleven as the most central one. The take away message from network 1 is clearly that choice matters. Depending on which index we choose, we can obtain very different results. Network 2 paints a completely different picture. All indices agree upon the most central node. Even better (or worse?), they all induce the same ranking. We can check that with the function <code>compare_ranks()</code> in the <code>netrankr</code> package by counting the wrongly ordered (discordant) pairs of nodes for pairs of indices <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>. That is, <span class="math inline">\(x\)</span> ranks a node <span class="math inline">\(i\)</span> before <span class="math inline">\(j\)</span> but <span class="math inline">\(y\)</span> ranks <span class="math inline">\(j\)</span> before <span class="math inline">\(i\)</span>.</p>
<div class="cell" data-hash="index_cache/html/ordering2_d763e30f9355d09361e7c3ea2ab1c200">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>discordant <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="dv">1</span>,<span class="dv">35</span><span class="sc">*</span><span class="dv">34</span>)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>k <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>(<span class="fu">ncol</span>(res2)<span class="sc">-</span><span class="dv">1</span>)){</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span>(j <span class="cf">in</span> (<span class="at">i=</span><span class="dv">1</span>)<span class="sc">:</span><span class="fu">ncol</span>(res2)){</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    k <span class="ot">&lt;-</span> k<span class="sc">+</span><span class="dv">1</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    discordant[k] <span class="ot">&lt;-</span> <span class="fu">compare_ranks</span>(res2[,i],res2[,j])<span class="sc">$</span>discordant</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="fu">any</span>(discordant<span class="sc">&gt;</span><span class="dv">0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] FALSE</code></pre>
</div>
</div>
<p>So, the indices not only agree upon the most central node, but also on the rest of the ranking!</p>
<p>You may be wondering, why we are only looking at the ranking and not the actual values. Effectively, the values themselves don’t have any meaning. There is no such thing as a “unit of centrality”, if we look at it from a measurement perspective. For instance, we can’t say that a node is “twice as between” as another if its betweenness value is twice as high. Centrality should thus not be considered to be on an interval scale, but rather an ordinal one. This might seem like a restriction at first, but we will see later on that it facilitates many theoretical examinations.</p>
<p>The two networks illustrate the big problem of choice. We have “only” tried 35 different indices, so we actually can’t make any conclusive statements about central nodes. After all, 35 indices can in the best case produce 35 completely different rankings. But theoretically, there are <span class="math inline">\(11! =\)</span> 39,916,800 possibilities to rank the nodes of the network without allowing ties, which indices actually do. So, what if we missed hundreds of thousands of potential indices that would rank, say, node nine on top for network 1? What if those 35 indices are exactly the ones that rank node eleven on top for network 2, but no other index does that?</p>
<p>In the next example, we add some (made up) empirical context to illustrate the problem of how to validate the appropriateness of chosen indices.</p>
</section>
<section id="an-almost-realistic-example" class="level2">
<h2 class="anchored" data-anchor-id="an-almost-realistic-example">An almost realistic example</h2>
<p>Centrality indices are commonly used as an explanatory variable for some observed phenomenon or node attribute in a network. Let’s say we have the following abstract research question. Given a network where each node is equipped with a binary attribute, which could signify the presence or absence of some property. Can a centrality index “explain” the presence of this attribute?</p>
<div class="cell" data-hash="index_cache/html/loadexamplebig_e5289bcfb62698cb8940728abb1a13eb">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co">#data can be found here: https://github.com/schochastics/centrality</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>g3 <span class="ot">&lt;-</span> <span class="fu">readRDS</span>(<span class="st">"example_3.rds"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><img src="example_big.png" class="img-fluid"></p>
<p>Instead of 35 indices, we here focus on the more common indices.</p>
<div class="cell" data-hash="index_cache/html/loadcent_1c9045af7f1723e04b7d7a5e9b601607">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>cent <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">nodes=</span><span class="dv">1</span><span class="sc">:</span><span class="fu">vcount</span>(g3),<span class="at">attr=</span><span class="fu">V</span>(g3)<span class="sc">$</span>attr)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>cent<span class="sc">$</span>degree <span class="ot">&lt;-</span> igraph<span class="sc">::</span><span class="fu">degree</span>(g3)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>cent<span class="sc">$</span>betweenness <span class="ot">&lt;-</span> igraph<span class="sc">::</span><span class="fu">betweenness</span>(g3)</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>cent<span class="sc">$</span>closeness <span class="ot">&lt;-</span> igraph<span class="sc">::</span><span class="fu">closeness</span>(g3)</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>cent<span class="sc">$</span>eigen <span class="ot">&lt;-</span> igraph<span class="sc">::</span><span class="fu">eigen_centrality</span>(g3)<span class="sc">$</span>vector</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>cent<span class="sc">$</span>subgraph <span class="ot">&lt;-</span> igraph<span class="sc">::</span><span class="fu">subgraph_centrality</span>(g3)</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>cent<span class="sc">$</span>infocent <span class="ot">&lt;-</span> sna<span class="sc">::</span><span class="fu">infocent</span>(<span class="fu">as_adj</span>(g3,<span class="at">sparse=</span>F))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>If we postulate that one of the indices is somehow related with the attribute, then we should see that nodes with the attribute should tend to be ranked on top of the induced ranking. The below bar chart shows the number of nodes having the attribute that are ranked in the top 150 for each index.</p>
<p><img src="attr150.png" class="img-fluid"></p>
<p>According to this evaluation, subgraph centrality is best in “explaining” the node attribute. But how conclusive is this now? Note that we did not specify any real hypothesis so basically any index could be a valid choice. Instead of trying out one of the other mentioned ones though, we now try to design a new index which hopefully gives us an even better “fit”. After some wild math, we may end up with something like this:</p>
<p><span class="math display">\[
c(u)= ccoef(u) \left[\sum\limits_{v \in N(u)} \sum\limits_{k=0}^{\infty} \frac{(A^{[u]})_{vv}^{2k}}{(2k)!} \right]
\]</span> Ok, so what is happening here? <span class="math inline">\(ccoef(u)\)</span> is the clustering coefficient of the node <span class="math inline">\(u\)</span> (<code>igraph::transitivity(g,type="local")</code>). The first sum is over all neighbors <span class="math inline">\(v\)</span> of <span class="math inline">\(u\)</span>. The second sum is used to sum up all closed walks of even length weighted by the inverse factorial of the length.</p>
<p>We can directly invent a second one, based on the walks of odd length. <span class="math display">\[
c(u)= ccoef(u) \left[\sum\limits_{v \in N(u)} \sum\limits_{k=0}^{\infty} \frac{(A^{[u]})_{vv}^{2k+1}}{(2k+1)!} \right]
\]</span> Mathematically fascinating, yet both indices defy any rational meaning.</p>
<p>Both indices have not yet been considered in the literature except in a <a href="http://kops.uni-konstanz.de/bitstream/handle/123456789/34821/Schoch_0-347789.pdf?sequence=3&amp;isAllowed=y">PhD thesis</a>. The indices are implemented in <code>netrankr</code> as the <em>hyperbolic index</em>.</p>
<div class="cell" data-hash="index_cache/html/example3hyp_345ccd52e7fea2088507b5ce8fae6e04">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>cent<span class="sc">$</span>hyp_eve <span class="ot">&lt;-</span> <span class="fu">hyperbolic_index</span>(g3,<span class="at">type =</span> <span class="st">"even"</span>)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>cent<span class="sc">$</span>hyp_odd <span class="ot">&lt;-</span> <span class="fu">hyperbolic_index</span>(g3,<span class="at">type =</span> <span class="st">"odd"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>How do they compare to the other indices?</p>
<p><img src="attr150_hyp.png" class="img-fluid"></p>
<p>Both indices are far superior. Around 66% of the top 150 nodes are equipped with the attribute, compared to 50% for subgraph centrality.</p>
<p>Obviously, this was a very contrived example, yet it emphasizes some important points. First, it is relatively easy to design an index that gives you the results you intend to get and hence justify the importance of the index. Second, you can never be sure, though, that you found “the best” index for the task. There may well be some even more obscure index that gives you better results. Third, if you do not find a fitting index, you can not be sure that there does not exist one after all.</p>
</section>
<section id="summary" class="level2">
<h2 class="anchored" data-anchor-id="summary">Summary</h2>
<p>The examples were intended to highlight some of the problems that you may encounter when using centrality indices and how hard it is to navigate the index landscape, keeping up with all the newly designed ones.</p>
<p>One is therefore all to often tempted to go down the data-minning road. That is, take a handfull of indices, check what works best and come up with a post-hoc explanation as to why the choice was reasonable. Note, though, that this approach is not universally bad, or wrong. It mainly depends on what you your intentions are. You simply want to have a sort of predictive model? Go wild on the indices and maximize! The <code>CINNA</code> package offers some excellent tools for that.</p>
<p>However, if you are working in a theory-heavy area, then this approach is not for you. “Trial-and-Error” approaches are hardly appropriate to test theories. But how can we properly test a hypothesis with measures of centrality, when obviously there is very little agreement in the proper procedure for centrality measurement?</p>
<p>In the upcoming sections, we discuss a different approach to centrality, which may help in translating a theoretical construct into a measure of centrality.</p>
</section>
</section>
<section id="part-2" class="level1">
<h1>Part 2</h1>
<section id="introduction-1" class="level2">
<h2 class="anchored" data-anchor-id="introduction-1">Introduction</h2>
<p>When looking at the vast amount of indices, it may be reasonable to ask if there is any natural limit for what can be considered a centrality index. Concretely, are there any theoretical properties that an index has to have in order to be called a centrality index? There exist several axiomatic systems for centrality, which define some desirable properties that a proper index should have. While these systems are able to shed some light on specific groups of indices, they are in most cases not comprehensive. That is, it is often possible to construct counterexamples for most indices such that they do not fulfill the properties. Instead of the rather normative axiomatic approach, we explore a more descriptive approach. We will address the following questions:</p>
<ul>
<li>Are there any properties that are shared by all (or almost all) indices?</li>
<li>If so, can they be exploited for a different kind of centrality analysis?</li>
</ul>
</section>
<section id="neighborhood-inclusion" class="level2">
<h2 class="anchored" data-anchor-id="neighborhood-inclusion">Neighborhood-inclusion</h2>
<p>In the first post, we examined the following two small examples.</p>
<div class="cell" data-hash="index_cache/html/loadexamples1_ca98a0da52f7f758041b901e4f7c1266">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co">#data can be found here: https://github.com/schochastics/centrality</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>g1 <span class="ot">&lt;-</span> <span class="fu">readRDS</span>(<span class="st">"example_1.rds"</span>)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>g2 <span class="ot">&lt;-</span> <span class="fu">readRDS</span>(<span class="st">"example_2.rds"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><img src="example.png" class="img-fluid"></p>
<p>It turned out that for network 1, 35 indices gave very different results and for network 2 they all coincided. In the following, we discuss why this is the case.</p>
<p>It turns out that there actually is a very intuitive structural property that underlies many centrality indices. If a node has exactly the same neighbors as another and potentially some more, it will never be less central, independent of the choice of index. Formally, <span class="math display">\[
N(i) \subseteq N[j] \implies c(i) \leq c(j)
\]</span> for centrality indices <span class="math inline">\(c\)</span>. This property is called <em>neighborhood-inclusion</em>.</p>
<p>An illustration is given below. <img src="neighborhood_inclusion.png%22" class="img-fluid"></p>
<p>Node <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> have three common neighbors (the black nodes), but <span class="math inline">\(j\)</span> has two additional neighbors (the grey nodes), hence <span class="math inline">\(i\)</span>’s neighborhood is included in the neighborhood of <span class="math inline">\(j\)</span>. Note that the inclusion is actually defined for the closed neighborhood (<span class="math inline">\(N[j]=N(j) \cup \{j\}\)</span>). This is due to some mathematical peculiarities when <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> are connected. Neighborhood-inclusion defines a partial ranking of the nodes. That is, some node pairs will not be comparable, because neither <span class="math inline">\(N(i) \subseteq N[j]\)</span> nor <span class="math inline">\(N(j) \subseteq N[i]\)</span> will hold. If the neighborhood of a node <span class="math inline">\(i\)</span> is properly contained in the neighborhood of <span class="math inline">\(j\)</span>, then we will say that <span class="math inline">\(i\)</span> is <em>dominated</em> by <span class="math inline">\(j\)</span>.</p>
<p>We can calculate all pairs of neighborhood-inclusion with the function <code>neighborhood_inclusion()</code> in the <code>netrankr</code> package.</p>
<div class="cell" data-hash="index_cache/html/ni_examples_bfbb1385bd631f90c273fc3c189540d8">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>P1 <span class="ot">&lt;-</span> <span class="fu">neighborhood_inclusion</span>(g1)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>P2 <span class="ot">&lt;-</span> <span class="fu">neighborhood_inclusion</span>(g2)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>An entry <span class="math inline">\(P[i,j]\)</span> is one if <span class="math inline">\(N(i)\subseteq N[j]\)</span> and zero otherwise. With the function <code>comparable_pairs()</code>, we can check the fraction of comparable pairs. Let us start with the first network.</p>
<div class="cell" data-hash="index_cache/html/comparable_example_24c2b819187421329bb3d7b26d8bc41a">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="fu">comparable_pairs</span>(P1)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.163636</code></pre>
</div>
</div>
<p>Only 16% of pairs are comparable with neighborhood-inclusion. For a better understanding of the dominance relations, we can also visualize them as a graph.</p>
<div class="cell" data-hash="index_cache/html/dom_graph1_886ca98368438b6e9305a5ac7f046b6e">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>d1 <span class="ot">&lt;-</span> <span class="fu">dominance_graph</span>(P1)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><img src="dominance1.png" class="img-fluid"></p>
<p>An edge <span class="math inline">\((i,j)\)</span> is present, if <span class="math inline">\(P[i,j]=1\)</span> and thus <span class="math inline">\(i\)</span> is dominated by <span class="math inline">\(j\)</span>. Centrality indices will always put these comparable pairs in the same order. To check this, we use the <code>all_indices()</code> function from the last post again.</p>
<div class="cell" data-hash="index_cache/html/indices_ex1_69bc95210e7201f0f059abc8bafe9bc7">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>res <span class="ot">&lt;-</span> <span class="fu">all_indices</span>(g1)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Let us focus on the triple <span class="math inline">\(1,3,5\)</span>.</p>
<div class="cell" data-hash="index_cache/html/triplet135_94311bd985f565b89548e8bf9ffae085">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>P1[<span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">5</span>),<span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">5</span>)] <span class="co">#(compare also with the dominance graph)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     [,1] [,2] [,3]
[1,]    0    1    1
[2,]    0    0    1
[3,]    0    0    0</code></pre>
</div>
</div>
<p>So, indices should rank them as <span class="math inline">\(1\leq3\leq 5\)</span>.</p>
<div class="cell" data-hash="index_cache/html/ranks135_2e9df193b263013ea80c6b513e373be9">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>ranks135 <span class="ot">&lt;-</span> <span class="fu">apply</span>(res[<span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">5</span>),],<span class="dv">2</span>,rank)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="fu">rownames</span>(ranks135) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">5</span>)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>ranks135</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] [,14]
1    1  1.5    1    1  1.5    1    1  1.5    1     1   1.5     1     1     1
3    2  1.5    2    2  1.5    2    2  1.5    2     2   1.5     2     2     2
5    3  3.0    3    3  3.0    3    3  3.0    3     3   3.0     3     3     3
  [,15] [,16] [,17] [,18] [,19] [,20] [,21] [,22] [,23] [,24] [,25] [,26] [,27]
1     1     1     1     1     1     1     2   1.5     1     1     1     1     1
3     2     2     2     2     2     2     2   1.5     2     2     2     2     2
5     3     3     3     3     3     3     2   3.0     3     3     3     3     3
  [,28] [,29] [,30] [,31] [,32] [,33] [,34] [,35]
1     1   1.0     1     1     1     1     1     1
3     2   2.5     2     2     2     2     2     2
5     3   2.5     3     3     3     3     3     3</code></pre>
</div>
</div>
<p>All 35 indices indeed produce a ranking that is in accordance with what we postulated. (Ties are allowed in the ranking since we require “<span class="math inline">\(\leq\)</span>” and not “<span class="math inline">\(&lt;\)</span>” ).</p>
<p>The <code>is_preserved()</code> function can be used to check if all dominance relations are preserved in the index induced rankings.</p>
<div class="cell" data-hash="index_cache/html/preserved35_26642350a9c963a75b6608bcb774f84f">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="fu">apply</span>(res,<span class="dv">2</span>, <span class="cf">function</span>(x) <span class="fu">is_preserved</span>(P1,x))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
[16] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
[31] TRUE TRUE TRUE TRUE TRUE</code></pre>
</div>
</div>
<p>For the other 84% of pairs that are not comparable by neighborhood-inclusion, indices are “at liberty” to rank nodes differently. Take the triple <span class="math inline">\(6,7,8\)</span> as an example.</p>
<div class="cell" data-hash="index_cache/html/triplet678_cabe0585c1d2fe6ddcc29505be21911b">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>P1[<span class="dv">6</span><span class="sc">:</span><span class="dv">8</span>,<span class="dv">6</span><span class="sc">:</span><span class="dv">8</span>] <span class="co">#(compare also with the dominance graph)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     [,1] [,2] [,3]
[1,]    0    0    0
[2,]    0    0    0
[3,]    0    0    0</code></pre>
</div>
</div>
<div class="cell" data-hash="index_cache/html/ranks678_4e9d4a4580e069c92db60f57dbbab549">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>ranks678 <span class="ot">&lt;-</span> <span class="fu">apply</span>(res[<span class="dv">6</span><span class="sc">:</span><span class="dv">8</span>,],<span class="dv">2</span>,rank)</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="fu">rownames</span>(ranks678) <span class="ot">&lt;-</span> <span class="dv">6</span><span class="sc">:</span><span class="dv">8</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="co"># unique rankings of 6,7,8</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>ranks678[,<span class="sc">!</span><span class="fu">duplicated</span>(<span class="fu">t</span>(ranks678))]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
6    2    2    3    2  2.5  2.5  1.5    3
7    2    1    1    3  1.0  2.5  1.5    2
8    2    3    2    1  2.5  1.0  3.0    1</code></pre>
</div>
</div>
<p>The 35 indices produce 8 distinct rankings of <span class="math inline">\(6,7,8\)</span>. This means that whenever a pair of nodes <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> are not comparable with neighborhood-inclusion, it is (theoretically) possible to construct an index for each of the three possible rankings (<span class="math inline">\(i&lt;j\)</span>, <span class="math inline">\(j&lt;i\)</span>, <span class="math inline">\(i\sim j\)</span>)</p>
<p>Moving on to the second network.</p>
<div class="cell" data-hash="index_cache/html/comparable2_358f1f11ad8e89ef358d3baaef0438da">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="fu">comparable_pairs</span>(P2)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 1</code></pre>
</div>
</div>
<p>So all pairs are comparable by neighborhood-inclusion. Hence, all indices will induce the same ranking (up to some potential tied ranks, but no discordant pairs), as we already observed in the previous post.</p>
</section>
<section id="threshold-graphs-and-correlation-among-indices" class="level2">
<h2 class="anchored" data-anchor-id="threshold-graphs-and-correlation-among-indices">Threshold graphs and correlation among indices</h2>
<p>The second example network is part of the class of <em>threshold graphs</em>. One of their defining features is that the partial ranking induced by neighborhood-inclusion is in fact a ranking. A random threshold graph can be created with the <code>threshold_graph()</code> function. The function takes two parameters, one for the number of nodes, and one (approximately) for the density. The class includes some well known graphs, such as complete graphs or star graphs.</p>
<p>We know from the previous section that centrality indices will always produce the same ranking on these graphs. This allows us to reason about another topic that is frequently investigated: correlations among indices. Correlations are often attributed to the definitions of indices. Take closeness and betweenness. On first glance, they measure very different things: Being close to all nodes and being “in between” all nodes. Hence, we would expect them to be only weakly correlated. But threshold graphs give us a reason to believe, that correlations are not entirely dependent on the definitions but rather on structural features of the network. (<a href="https://www.sciencedirect.com/science/article/pii/S0378873316303690">This article</a> gives more details and references on that topic).</p>
<p>As an illustration, we compare betweenness and closeness on a threshold graph and a threshold graph with added noise from a random graph.</p>
<div class="cell" data-hash="index_cache/html/tg_noise_37e12e0acb58c0e91f82cf182ec11dae">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="co">#threshold graph</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>tg3 <span class="ot">&lt;-</span> <span class="fu">threshold_graph</span>(<span class="dv">100</span>,<span class="fl">0.2</span>)</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="co">#noise graph</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>gnp <span class="ot">&lt;-</span> <span class="fu">sample_gnp</span>(<span class="dv">100</span>,<span class="fl">0.01</span>,<span class="at">directed =</span> <span class="cn">FALSE</span>)</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>A1 <span class="ot">&lt;-</span> <span class="fu">get.adjacency</span>(tg3,<span class="at">sparse=</span><span class="cn">FALSE</span>)</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>A2 <span class="ot">&lt;-</span> <span class="fu">get.adjacency</span>(gnp,<span class="at">sparse=</span><span class="cn">FALSE</span>)</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a><span class="co">#construct a noise threshold graph</span></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>tg3_noise <span class="ot">&lt;-</span> <span class="fu">graph_from_adjacency_matrix</span>(<span class="fu">xor</span>(A1,A2),<span class="at">mode =</span> <span class="st">"undirected"</span>)</span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a><span class="co">#calculate discordant pairs for betweenness and closeness in both networks</span></span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a>disc1 <span class="ot">&lt;-</span> <span class="fu">compare_ranks</span>(<span class="fu">betweenness</span>(tg3),<span class="fu">closeness</span>(tg3))<span class="sc">$</span>discordant</span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a>disc2 <span class="ot">&lt;-</span> <span class="fu">compare_ranks</span>(<span class="fu">betweenness</span>(tg3_noise),<span class="fu">closeness</span>(tg3_noise))<span class="sc">$</span>discordant</span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true" tabindex="-1"></a><span class="fu">c</span>(disc1,disc2)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1]   0 484</code></pre>
</div>
</div>
<p>On the threshold graph we do not observe any discordant pairs for the two indices. However, the little noise we added to the threshold graph was enough to introduce 484 pairs of nodes that are now ranked differently. In general, we can say that</p>
<p><em>The closer a network is to be a threshold graph, the higher we expect the correlation of any pair of centrality indices to be, independent of their definition.</em></p>
<p>But how to define <em>being close</em> to a threshold graph? One obvious choice is to use the function <code>comparable_pairs()</code>. The more pairs are comparable, the less possibilities for indices to rank the nodes differently. Hence, we are close to a unique ranking obtained for threshold graphs. A second option is to use an appropriate distance measure for graphs. <code>netrankr</code> implements the so called <em>majorization gap</em> which operates on the degree sequences of graphs. In its essence, it returns the number of edges that need to be rewired, in order to turn an arbitrary graph into a threshold graph.</p>
<div class="cell" data-hash="index_cache/html/major_867c81737025b670794eda061e3a137c">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>mg1 <span class="ot">&lt;-</span> <span class="fu">majorization_gap</span>(tg3)</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>mg2 <span class="ot">&lt;-</span> <span class="fu">majorization_gap</span>(tg3_noise)</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span class="fu">c</span>(mg1,mg2)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.0000000 0.0254873</code></pre>
</div>
</div>
<p>The result is given as a fraction of the total number of edges. So 3% of edges need to be rewired in the noisy graph to turn it into a threshold graph. To get the raw count, set <code>norm=FALSE</code>.</p>
<div class="cell" data-hash="index_cache/html/major_raw_7f7d4da15dcf6118f7b901c239edc64c">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="fu">majorization_gap</span>(tg3_noise,<span class="at">norm =</span> <span class="cn">FALSE</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 34</code></pre>
</div>
</div>
</section>
<section id="summary-1" class="level2">
<h2 class="anchored" data-anchor-id="summary-1">Summary</h2>
<p>Neighborhood-inclusion seems to be a property that underlies many centrality indices. If a node <span class="math inline">\(i\)</span> is dominated by another node <span class="math inline">\(j\)</span>, then (almost) any index will rank <span class="math inline">\(j\)</span> higher than <span class="math inline">\(i\)</span>. I am not going to make the bold statement of saying that <strong>all</strong> centrality indices have this property, although all commonly used and traditional indices have this property. However, it is easy to come up with an index that doesn’t preserve the partial ranking (Coincidentally, the two hyperbolic indices from the first post don’t preserve it. Thank god!). But if we accept the preservation of neighborhood-inclusion to be a defining property of centrality indices, then we are able to a) derive more theoretical results about centrality (see correlation section) b) distinguish proper indices from invalid ones (see hyperbolic indices) and c) think about new ways of assessing centrality, that do not necessarily rely on indices.</p>
<p>Point c) will be partially addressed in the next post and in more detail in subsequent ones.<br>
The main focus for the next post is on how to extend neighborhood-inclusion to other forms of dominance. Additionally, we will see how to deconstruct indices into a series of building blocks, which allows for a deeper understanding on what indices actually “measure”.</p>
</section>
</section>
<section id="part-3" class="level1">
<h1>Part 3</h1>
<section id="introduction-2" class="level2">
<h2 class="anchored" data-anchor-id="introduction-2">Introduction</h2>
<p>Neighborhood-inclusion seems to underlie many different centrality indices and as such serves (or better: could serve) as a defining property of a centrality index. That is:</p>
<blockquote class="blockquote">
<p>An index is a measure of centrality if and only if it preserves the partial ranking induced by neighborhood-inclusion</p>
</blockquote>
<p>While this gives as a theoretical basis for centrality, it comes with a bit of problem. Namely, that we do not expect many comparable pairs in (large) real-world networks. Take the third example network from the first post.</p>
<div class="cell" data-hash="index_cache/html/gni1_8d70a60f3854384b90eca35cb119bee6">
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>g3 <span class="ot">&lt;-</span> <span class="fu">readRDS</span>(<span class="st">"example_3.rds"</span>)</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>P <span class="ot">&lt;-</span> <span class="fu">neighborhood_inclusion</span>(g3)</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a><span class="fu">comparable_pairs</span>(P)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.00600532</code></pre>
</div>
</div>
<p>Only 0.6% of pairs are comparable. This means that centrality indices are at liberty to rank 99.4% of pairs in any order. So, neighborhood-inclusion may not be very restrictive in large networks. This is much like with <em>structural equivalence</em>. It is a very intuitive concept for equivalences in networks (having exactly the same neighbors), however we do not expect many equivalent pairs in large networks. This does not render the concept useless, but requires some relaxations.</p>
<p>In the following, we introduce dominance relations, which incrementally extend the partial ranking of neighborhood-inclusion and thus tighten the partial ranking that indices preserve. We start by illustrating how indices can be decomposed into a series of building blocks.</p>
</section>
<section id="deconstructing-indices" class="level2">
<h2 class="anchored" data-anchor-id="deconstructing-indices">Deconstructing Indices</h2>
<p>Centrality indices assess structural importance based on a great variety of different graph theoretic notions, like shortest paths (closeness) or walks (subgraph centrality). Implicitly, though, they all follow a simple recipe:</p>
<ul>
<li>derive an indirect relation</li>
<li>aggregate the indirect relations</li>
</ul>
<p>As mentioned above, indirect relation are commonly derived via graph trajectories such as paths and walks, for instance to compute distances. The aggregation is usually a simple summation of all relations of a node, but others are possible too (e.g.&nbsp;<span class="math inline">\(\max\)</span> as in eccentricity). In its most generic form, we can thus write a centrality index as <span class="math display">\[
c(i)= \sum_j \tau(x)_{ij}
\]</span> where <span class="math inline">\(x\)</span> are the observed relations (basically the adjacency matrix) and <span class="math inline">\(\tau\)</span> a generic transformation function. Replacing <span class="math inline">\(\tau\)</span> with <span class="math inline">\(id\)</span>, we obtain degree centrality and setting <span class="math inline">\(\tau=dist\)</span>, we obtain closeness. A suitable function <span class="math inline">\(\tau\)</span> can be defined for all centrality indices, such that any index can basically be seen as degree in an appropriately transformed network.</p>
<p>The package <code>netrankr</code> provides a set of 24 different indirect relations that can be used to construct indices. A few common examples are given below.</p>
<div class="cell" data-hash="index_cache/html/indices_9a035b431dd2d62a8e9f86ba50e7bba4">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="co">#closeness </span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>g <span class="sc">|&gt;</span> </span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">indirect_relations</span>(<span class="at">type=</span><span class="st">'dist_sp'</span>) <span class="sc">|&gt;</span> </span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">aggregate_positions</span>(<span class="at">type=</span><span class="st">'invsum'</span>)</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a><span class="co">#betweenness</span></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>g <span class="sc">|&gt;</span> </span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">indirect_relations</span>(<span class="at">type=</span><span class="st">'depend_sp'</span>) <span class="sc">|&gt;</span> </span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">aggregate_positions</span>(<span class="at">type=</span><span class="st">'sum'</span>)</span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a><span class="co">#eigenvector</span></span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true" tabindex="-1"></a>g <span class="sc">|&gt;</span> </span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true" tabindex="-1"></a>  <span class="fu">indirect_relations</span>(<span class="at">type=</span><span class="st">'walks'</span>,<span class="at">FUN=</span>walks_limit_prop) <span class="sc">|&gt;</span> </span>
<span id="cb37-14"><a href="#cb37-14" aria-hidden="true" tabindex="-1"></a>  <span class="fu">aggregate_positions</span>(<span class="at">type=</span><span class="st">'sum'</span>)</span>
<span id="cb37-15"><a href="#cb37-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-16"><a href="#cb37-16" aria-hidden="true" tabindex="-1"></a><span class="co">#subgraph </span></span>
<span id="cb37-17"><a href="#cb37-17" aria-hidden="true" tabindex="-1"></a>g <span class="sc">|&gt;</span> </span>
<span id="cb37-18"><a href="#cb37-18" aria-hidden="true" tabindex="-1"></a>  <span class="fu">indirect_relations</span>(<span class="at">type=</span><span class="st">'walks'</span>,<span class="at">FUN=</span>walks_exp) <span class="sc">|&gt;</span> </span>
<span id="cb37-19"><a href="#cb37-19" aria-hidden="true" tabindex="-1"></a>  <span class="fu">aggregate_positions</span>(<span class="at">type=</span><span class="st">'self'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Consult the help for <code>indirect_relations()</code> to see all options.<br>
Note that we make use of the <code>|&gt;</code> operator. This should appeal to the recipe idea from above: <code>network |&gt; indirect_relation |&gt; aggregation</code> (but requires R Version &gt;4.0). The package also includes a handy RStudio addin, which can be used to build the pipelines more easily.</p>
<p>Defining indices in this way is certainly more cumbersome than using, say, <code>betweennes(g)</code>. However, it allows us to intervene at any step and <em>do something else</em>.</p>
</section>
<section id="extended-dominance-relations" class="level2">
<h2 class="anchored" data-anchor-id="extended-dominance-relations">Extended Dominance Relations</h2>
<p>To illustrate the “something else”, we look at our first small example network again.</p>
<div class="cell" data-hash="index_cache/html/loadexamples2_8576f1310a561c852f346c6826efe856">
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>g1 <span class="ot">&lt;-</span> <span class="fu">readRDS</span>(<span class="st">"example_1.rds"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Following the recipe, you have decided, that the <em>relations of interest</em> for your analysis are the distances between nodes. The problem is, aggregating them into an index can still be done in various ways. Three distance based centrality examples are shown below.</p>
<div class="cell" data-hash="index_cache/html/distance_based_f31ecc057c760f36b6fbd0b4d9f1ce8b">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="co">#classic closeness</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>c_C <span class="ot">&lt;-</span> g1 <span class="sc">|&gt;</span> </span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">indirect_relations</span>(<span class="at">type=</span><span class="st">"dist_sp"</span>) <span class="sc">|&gt;</span> </span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">aggregate_positions</span>(<span class="at">type=</span><span class="st">"invsum"</span>)</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a><span class="co">#harmonic closeness</span></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>c_HC <span class="ot">&lt;-</span> g1 <span class="sc">|&gt;</span> </span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">indirect_relations</span>(<span class="at">type=</span><span class="st">"dist_sp"</span>,<span class="at">FUN=</span>dist_inv) <span class="sc">|&gt;</span> </span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">aggregate_positions</span>(<span class="at">type=</span><span class="st">"sum"</span>)</span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a><span class="co">#residual-type closeness</span></span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a>c_RC <span class="ot">&lt;-</span> g1 <span class="sc">|&gt;</span> </span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a>  <span class="fu">indirect_relations</span>(<span class="at">type=</span><span class="st">"dist_sp"</span>,<span class="at">FUN=</span>dist_2pow) <span class="sc">|&gt;</span> </span>
<span id="cb39-14"><a href="#cb39-14" aria-hidden="true" tabindex="-1"></a>  <span class="fu">aggregate_positions</span>(<span class="at">type=</span><span class="st">"sum"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Any of the above indices starts with the derivation of distances, but then proceeds with a different form of aggregation: <span class="math display">\[
c_C(i)=\frac{1}{\sum dist(i,j)},\quad c_{HC}(i)=\sum\frac{1}{dist(i,j)}, \quad c_{RC}(i)=\sum 2^{-dist(i,j)}
\]</span> Possibilities are virtually endless for aggregating distances into an index. From the previous part, we know that any of these indices preserve neighborhood-inclusion. Once we have settled for a relation, as in this case, we can extend the partial ranking using the following considerations: If a <span class="math inline">\(dist(i,k)\)</span> is larger than <span class="math inline">\(dist(j,k)\)</span> for all nodes <span class="math inline">\(k\)</span>, then no matter how we aggregate the relations (as long as it is monotonic), <span class="math inline">\(i\)</span> will always be less central then <span class="math inline">\(j\)</span>. With a bit more formalism: <span class="math display">\[
dist(i,k) \geq dist(j,k) \text{ for all } k \implies c_x(i)\leq c_x(j)
\]</span> where <span class="math inline">\(c_x\)</span> is an arbitrary centrality index based on distances. This actually defines a new dominance relation among nodes. In fact, we can go a step further. It does not really matter in which order we aggregate the distances, the result will always be the same. Hence, we can permute all relations of a single node without affecting the result. A convenient choice of permutation is simply to reorder all relations in descending order. Afterwards, we can compute the dominance relations as above. (More formal details on these dominance relations can be found in <a href="https://journals.sagepub.com/doi/abs/10.1177/2059799116630650">this article</a>.)</p>
<p>We can compute this new dominance relation using the function <code>positional_dominance()</code>. The <code>benefit</code> parameter is set to <code>FALSE</code> since large distances are not beneficial for a node to have. Setting <code>map=TRUE</code> invokes the above mentioned reordering. For comparison, we also compute neighborhood-inclusion again.</p>
<div class="cell" data-hash="index_cache/html/positional_dominance_51e4a2737eb6a2451002efc02272aa19">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>P <span class="ot">&lt;-</span> <span class="fu">neighborhood_inclusion</span>(g1)</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>D <span class="ot">&lt;-</span> g1 <span class="sc">|&gt;</span> </span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">indirect_relations</span>(<span class="at">type=</span><span class="st">"dist_sp"</span>) <span class="sc">|&gt;</span> </span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">positional_dominance</span>(<span class="at">benefit=</span><span class="cn">FALSE</span>,<span class="at">map=</span><span class="cn">TRUE</span>)</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a><span class="fu">c</span>(<span class="st">"neighborhood-inclusion"</span><span class="ot">=</span><span class="fu">comparable_pairs</span>(P),<span class="st">"distance dominance"</span><span class="ot">=</span><span class="fu">comparable_pairs</span>(D))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>neighborhood-inclusion     distance dominance 
              0.163636               0.872727 </code></pre>
</div>
</div>
<p>By fixing our relation of interest to distances and allowing reordering of relations, we went from only 16% of comparable pairs to 87%! Hence, no matter what index based on distance we use, results will always be very similar. As a sanity check, we can verify that all distance based indices from above preserve the dominance relations.</p>
<div class="cell" data-hash="index_cache/html/pdpreserved_934afd3647bcba57af551519048eceb4">
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="fu">c</span>(<span class="st">"classic"</span><span class="ot">=</span><span class="fu">is_preserved</span>(D,c_C),<span class="st">"harmonic"</span><span class="ot">=</span><span class="fu">is_preserved</span>(D,c_HC),<span class="st">"residual"</span><span class="ot">=</span><span class="fu">is_preserved</span>(D,c_RC))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> classic harmonic residual 
    TRUE     TRUE     TRUE </code></pre>
</div>
</div>
</section>
</section>
<section id="partial-centrality" class="level1">
<h1>Partial Centrality</h1>
<p>By now, we should have understood that there are various kinds of partial rankings in networks, which form the basis of centrality. Indices extend these partial rankings into <strong>one</strong> possible ranking, but, as we will see later, there might be hundreds of thousands of possible rankings. And hence, hundreds of thousands of indices that produce these rankings. Instead of inventing hundreds of thousands of indices, why not just study the partial rankings? Or why not be extremely bold, and try to analyse <strong>all</strong> possible rankings at once?</p>
<p>In this section, we consider the former question, by introducing <em>rank intervals</em>. A rank interval of a node is the set of ranks a node can have in any ranking that extends a given partial ranking. Let us consider two extreme cases. A node that is neither dominated nor dominates any other node can potentially have any rank. So its rank interval is <span class="math inline">\([1,n]\)</span>. (We use the convention, that <span class="math inline">\(n\)</span> is the top rank and <span class="math inline">\(1\)</span> the lowest possible rank). On the other hand, if a node dominates all other nodes, it can only be ranked on the top. So its rank interval is just a point.</p>
<p><code>netrankr</code> includes the function <code>rank_intervals()</code> which returns the rank intervals for all nodes in the network. A visual representation of the intervals can be obtained by using the <code>plot()</code> function, as done below for the first example network and neighborhood-inclusion as partial ranking input. We also included an optional <code>data.frame</code> containing centrality scores of five indices.</p>
<div class="cell" data-hash="index_cache/html/rank_intervals_all_98c5b901738b1de8e1784e3eb9f4f026">
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>cent_scores <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>   <span class="at">degree=</span><span class="fu">degree</span>(g1),</span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>   <span class="at">betweenness=</span><span class="fu">betweenness</span>(g1),</span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>   <span class="at">closeness=</span><span class="fu">closeness</span>(g1),</span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>   <span class="at">eigen=</span><span class="fu">eigen_centrality</span>(g1)<span class="sc">$</span>vector,</span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a>   <span class="at">subgraph=</span><span class="fu">subgraph.centrality</span>(g1))</span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">rank_intervals</span>(P),<span class="at">cent.df =</span> cent_scores)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/rank_intervals_all-1.png" class="img-fluid" style="width:100.0%"></p>
</div>
</div>
<p>The rank intervals are extremely big for this network. Node 10, for instance can take any possible rank. The most constraint interval is that of node 1, containing 6 possible ranks. The rank intervals can be interpreted as a sort of confidence interval for centrality. The larger the interval, the less explanatory power a single index may have Again, consider Node 10. It is the most central node according to subgraph centrality, but ranks very low in betweenness.</p>
<p>We have learned that we can extend neighborhood-inclusion by choosing a relation of interest as basis for our analysis. For the example network, we considered distances. The below figure shows the resulting rank intervals.</p>
<div class="cell" data-hash="index_cache/html/rank_intervals_dist_eaa47db9fad6b299220710d06d726471">
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>cent_scores <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>   <span class="at">classic=</span>c_C,</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>   <span class="at">harmonic=</span>c_HC,</span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>   <span class="at">residual=</span>c_RC)</span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">rank_intervals</span>(D),<span class="at">cent.df =</span> cent_scores)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/rank_intervals_dist-1.png" class="img-fluid" style="width:100.0%"></p>
</div>
</div>
<p>Notice how much smaller they got. The intervals of node 1 and 2 even collapse into a single point. They will thus always be ranked at the bottom in any distance based centrality ranking.</p>
<p>Rank intervals are a convenient choice to assess the possibilities of rankings in a network. It is important to understand, though, that the ranks in each interval do not occur with uniform probability. A rank interval <span class="math inline">\([6,7]\)</span> does not mean that the node is ranked 6th in 50% of all possible rankings. We address the <em>rank probabilities</em> in the next section.</p>
<section id="probabilistic-centrality" class="level2">
<h2 class="anchored" data-anchor-id="probabilistic-centrality">Probabilistic Centrality</h2>
<p>A node ranking can be defined as a mapping <span class="math display">\[rk: V \to \{1,\ldots,n\},\]</span> where we use the convention that <span class="math inline">\(u\)</span> is the top ranked node if <span class="math inline">\(rk(u)=n\)</span> and the bottom ranked one if <span class="math inline">\(rk(u)=1\)</span>. The set of all possible rankings can then be characterized as <span class="math display">\[
\mathcal{R}(\leq)=\{rk:V \to \{1,\ldots,n\}\; : \; u\leq v \implies rk(u)\leq rk(v)\}.
\]</span> This set contains all rankings that could be obtained for centrality indices that preserve the partial ranking of a dominance relation “<span class="math inline">\(\leq\)</span>”.</p>
<p>Once <span class="math inline">\(\mathcal{R}(\leq)\)</span> is calculated, it can be used for a probabilistic assessment of centrality, analyzing all possible rankings at once. Examples include <em>relative rank probabilities</em> (How likely is it, that a node <span class="math inline">\(u\)</span> is more central than another node <span class="math inline">\(v\)</span>?) or <em>expected ranks</em> (How central do we expect a node <span class="math inline">\(u\)</span> to be).</p>
<p><code>netrankr</code> includes the function <code>exact_rank_prob()</code>, which helps to answer the above posted questions. We stick with our small example network and apply the function to both, neighborhood-inclusion and dominance based on distances.</p>
<div class="cell" data-hash="index_cache/html/probs_fb7e88a9e4e32d299a248c543d4f68c6">
<div class="sourceCode cell-code" id="cb46"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>probNI <span class="ot">&lt;-</span> <span class="fu">exact_rank_prob</span>(P) </span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>probD  <span class="ot">&lt;-</span> <span class="fu">exact_rank_prob</span>(D)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The function returns a large list of different outputs, which we discuss in the following. The number of possible rankings is stored in <code>lin.ext</code>.</p>
<div class="cell" data-hash="index_cache/html/no_of_rks_564efe041f702df9d55a8e06ea9422ae">
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="fu">c</span>(<span class="st">"neighborhood-inclusion"</span><span class="ot">=</span>probNI<span class="sc">$</span>lin.ext,<span class="st">"distances"</span><span class="ot">=</span>probD<span class="sc">$</span>lin.ext)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>neighborhood-inclusion              distances 
                739200                     20 </code></pre>
</div>
</div>
<p>So, for this tiny network, there are still more than 700,000 possibilities to rank the nodes differently. If we restrict ourselves to distances, we end up with only 20.</p>
<p>The rank probabilities (for example how likely is it that node <span class="math inline">\(u\)</span> is ranked on top?) are stored in the matrix <code>rank.prob</code>. We here focus on the probability to be the most central node.</p>
<div class="cell" data-hash="index_cache/html/rank_probsNI_9c30b9f362b15c8dab8b92489ad4c0e4">
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>top_rank <span class="ot">&lt;-</span> <span class="fu">ncol</span>(probNI<span class="sc">$</span>rank.prob)</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>probNI<span class="sc">$</span>rank.prob[,<span class="dv">11</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>       V1        V2        V3        V4        V5        V6        V7        V8 
0.0000000 0.0000000 0.0000000 0.1363636 0.1636364 0.1090909 0.1090909 0.1363636 
       V9       V10       V11 
0.0909091 0.0909091 0.1636364 </code></pre>
</div>
</div>
<p>Node 5 and 11 have the highest probability to be the most central node. You can think of the probabilities as follows: If we would apply thousands of indices to the network, in 16% of the cases will node 5 be the most central node.</p>
<p>Relative rank probabilities (How likely is it that <span class="math inline">\(u\)</span> is less central than <span class="math inline">\(v\)</span>?) are stored in the matrix <code>relative.rank</code>.</p>
<div class="cell" data-hash="index_cache/html/relranksNI_d87d44b98be1716d6555510a455db411">
<div class="sourceCode cell-code" id="cb51"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="fu">round</span>(probNI<span class="sc">$</span>relative.rank,<span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>      V1   V2   V3   V4   V5   V6   V7   V8   V9  V10  V11
V1  0.00 0.67 1.00 0.95 1.00 1.00 1.00 0.95 0.86 0.86 1.00
V2  0.33 0.00 0.67 1.00 0.92 0.83 0.83 1.00 0.75 0.75 0.92
V3  0.00 0.33 0.00 0.80 1.00 0.75 0.75 0.80 0.64 0.64 1.00
V4  0.05 0.00 0.20 0.00 0.56 0.44 0.44 0.50 0.38 0.38 0.56
V5  0.00 0.08 0.00 0.44 0.00 0.38 0.38 0.44 0.32 0.32 0.50
V6  0.00 0.17 0.25 0.56 0.62 0.00 0.50 0.56 0.43 0.43 0.62
V7  0.00 0.17 0.25 0.56 0.62 0.50 0.00 0.56 0.43 0.43 0.62
V8  0.05 0.00 0.20 0.50 0.56 0.44 0.44 0.00 0.38 0.38 0.56
V9  0.14 0.25 0.36 0.62 0.68 0.57 0.57 0.62 0.00 0.50 0.68
V10 0.14 0.25 0.36 0.62 0.68 0.57 0.57 0.62 0.50 0.00 0.68
V11 0.00 0.08 0.00 0.44 0.50 0.37 0.37 0.44 0.32 0.32 0.00</code></pre>
</div>
</div>
<p>For example, the probability that node 2 is less central than node 1 is <span class="math inline">\(0.33\)</span>. The closer a probability to <span class="math inline">\(0.5\)</span> (see node 11 and 5), the less reason exists to put either node on top of the other.</p>
<p>The last return values of interest are the expected ranks and the standard deviation in <code>expected.rank</code> and <code>rank.spread</code>. The expected ranks can be seen as a sort of baseline ranking. Applying hundreds of random indices, this is the ranking we could expect to get on average.</p>
<div class="cell" data-hash="index_cache/html/exprksNI_a1084266299300ee0afea720e740e288">
<div class="sourceCode cell-code" id="cb53"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>exp_rk <span class="ot">&lt;-</span> <span class="fu">round</span>(probNI<span class="sc">$</span>expected.rank,<span class="dv">2</span>)</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>sd_rk <span class="ot">&lt;-</span> <span class="fu">round</span>(probNI<span class="sc">$</span>rank.spread,<span class="dv">2</span>)</span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a>exp_rk</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  V1   V2   V3   V4   V5   V6   V7   V8   V9  V10  V11 
1.71 3.00 4.29 7.50 8.14 6.86 6.86 7.50 6.00 6.00 8.14 </code></pre>
</div>
<div class="sourceCode cell-code" id="cb55"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>sd_rk</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  V1   V2   V3   V4   V5   V6   V7   V8   V9  V10  V11 
0.96 1.90 1.72 2.54 2.16 2.72 2.72 2.54 3.16 3.16 2.16 </code></pre>
</div>
</div>
<p>The standard deviations are quite large for neighborhood-inclusion, which was to be expected from the big rank intervals. Below, we calculate the expected ranks for the distance based dominance.</p>
<div class="cell" data-hash="index_cache/html/exprksD_7e7d97c861080eedbd7b99aa43ef5c7c">
<div class="sourceCode cell-code" id="cb57"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a>exp_rk <span class="ot">&lt;-</span> <span class="fu">round</span>(probD<span class="sc">$</span>expected.rank,<span class="dv">2</span>)</span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>sd_rk <span class="ot">&lt;-</span> <span class="fu">round</span>(probD<span class="sc">$</span>rank.spread,<span class="dv">2</span>)</span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>exp_rk</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  V1   V2   V3   V4   V5   V6   V7   V8   V9  V10  V11 
 2.0  1.0  3.5  3.5  5.3 10.7  6.6  9.4  9.4  6.2  9.8 </code></pre>
</div>
<div class="sourceCode cell-code" id="cb59"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>sd_rk</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  V1   V2   V3   V4   V5   V6   V7   V8   V9  V10  V11 
0.00 0.00 0.50 0.50 0.46 0.46 0.49 0.49 0.49 0.98 0.98 </code></pre>
</div>
</div>
<p>As a word of warning: The problem of finding all possible rankings for a partial ranking is computationally a hard problem. So it is advisable to use <code>exact_rank_prob()</code> only for small networks. Some benchmark results and approximation methods for larger networks can be found <a href="http://netrankr.schochastics.net/articles/benchmarks.html">here</a>.</p>
</section>
<section id="summary-2" class="level2">
<h2 class="anchored" data-anchor-id="summary-2">Summary</h2>
<p>After this part, it is time to take stock of what we have done so far. To date, putting it bluntly, network centrality is nothing more than the application of indices to a network:</p>
<p><img src="%22diagram_old.png%22" class="img-fluid"></p>
<p>The only degree of freedom is the choice of index and it is hard to justify choices without resorting to data-driven reasoning, as in “We used betweenness because it worked best”.</p>
<p>The introduced neighborhood-inclusion and more specific dominance concepts allow for additional ways of analyzing centrality in networks, described in this superficial diagram.</p>
<p><img src="%22diagram_new.png%22" class="img-fluid"></p>
<p>Any centrality analysis starts with identifying the <em>relation of interest</em>, which replaces the choice of index. The relation of interest is usually some graph-theoretic property (e.g.&nbsp;distances) that we assume to be indicative for centrality. The relations of a node to all others is called its <em>position</em>. The aggregation of the relations leads to the definition of indices, hence the usual centrality concept. However, positions can also be compared via <em>positional dominance</em>, the dominance relation introduced in this post, leading to partial centrality rankings and the option to calculate probabilistic centrality rankings.</p>
</section>
</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents"><h2 class="anchored quarto-appendix-heading">Citation</h2><div><div class="quarto-appendix-secondary-label">BibTeX citation:</div><pre class="sourceCode code-with-copy quarto-appendix-bibtex"><code class="sourceCode bibtex">@online{schoch2022,
  author = {David Schoch},
  title = {Network {Centrality} in {R}},
  date = {22-04-27},
  url = {https://github.com/schochastics/centrality},
  langid = {en}
}
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre><div class="quarto-appendix-secondary-label">For attribution, please cite this work as:</div><div id="ref-schoch2022" class="csl-entry quarto-appendix-citeas" role="doc-biblioentry">
David Schoch. 22AD. <span>“Network Centrality in R.”</span> April 27,
22AD. <a href="https://github.com/schochastics/centrality">https://github.com/schochastics/centrality</a>.
</div></div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>